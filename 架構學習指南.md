# C# 架構學習指南 - CioSystem v1

## 學習目標

本指南將帶領您學習現代 C# 應用程式的架構設計和最佳實踐，透過實作一個完整的庫存管理系統來掌握核心概念。

## 第一部分：架構基礎

### 1.1 分層架構 (Layered Architecture)

分層架構是企業級應用程式最常用的架構模式，將應用程式分為多個層級，每層都有明確的職責。

```
┌─────────────────────────────────────┐
│           展示層 (Presentation)      │
│         (Controllers, Views)        │
├─────────────────────────────────────┤
│           應用層 (Application)       │
│         (Services, DTOs)           │
├─────────────────────────────────────┤
│           領域層 (Domain)           │
│         (Models, Interfaces)       │
├─────────────────────────────────────┤
│           基礎設施層 (Infrastructure) │
│         (Data, External APIs)      │
└─────────────────────────────────────┘
```

#### 各層職責：

**展示層 (Presentation Layer)**
- 處理 HTTP 請求和回應
- 資料驗證和格式化
- 使用者介面邏輯

**應用層 (Application Layer)**
- 協調業務流程
- 處理應用程式特定的邏輯
- 管理交易和安全性

**領域層 (Domain Layer)**
- 核心業務邏輯
- 實體和值物件
- 領域服務和介面

**基礎設施層 (Infrastructure Layer)**
- 資料存取實作
- 外部服務整合
- 技術細節實作

### 1.2 SOLID 原則

SOLID 是物件導向程式設計的五個基本原則：

#### S - 單一職責原則 (Single Responsibility Principle)
每個類別應該只有一個改變的理由。

```csharp
// ❌ 違反 SRP - 一個類別負責多個職責
public class ProductManager
{
    public void CreateProduct(Product product) { }
    public void SendEmail(string email) { }
    public void SaveToDatabase(Product product) { }
}

// ✅ 遵循 SRP - 每個類別只有一個職責
public class ProductService
{
    public void CreateProduct(Product product) { }
}

public class EmailService
{
    public void SendEmail(string email) { }
}

public class ProductRepository
{
    public void Save(Product product) { }
}
```

#### O - 開放封閉原則 (Open/Closed Principle)
軟體實體應該對擴展開放，對修改封閉。

```csharp
// ✅ 使用抽象介面，便於擴展
public interface IPaymentProcessor
{
    void ProcessPayment(decimal amount);
}

public class CreditCardProcessor : IPaymentProcessor
{
    public void ProcessPayment(decimal amount) { }
}

public class PayPalProcessor : IPaymentProcessor
{
    public void ProcessPayment(decimal amount) { }
}
```

#### L - 里氏替換原則 (Liskov Substitution Principle)
子類別應該能夠替換其父類別。

#### I - 介面隔離原則 (Interface Segregation Principle)
客戶端不應該依賴於它不使用的介面。

```csharp
// ❌ 違反 ISP - 介面過於龐大
public interface IUserOperations
{
    void CreateUser(User user);
    void UpdateUser(User user);
    void DeleteUser(int id);
    void SendEmail(string email);
    void GenerateReport();
}

// ✅ 遵循 ISP - 拆分為多個小介面
public interface IUserRepository
{
    void Create(User user);
    void Update(User user);
    void Delete(int id);
}

public interface IEmailService
{
    void SendEmail(string email);
}
```

#### D - 依賴反轉原則 (Dependency Inversion Principle)
高層模組不應該依賴低層模組，兩者都應該依賴抽象。

```csharp
// ❌ 違反 DIP - 直接依賴具體實作
public class ProductService
{
    private SqlServerRepository repository = new SqlServerRepository();
}

// ✅ 遵循 DIP - 依賴抽象介面
public class ProductService
{
    private readonly IRepository<Product> repository;
    
    public ProductService(IRepository<Product> repository)
    {
        this.repository = repository;
    }
}
```

## 第二部分：設計模式

### 2.1 Repository Pattern (儲存庫模式)

Repository 模式封裝了資料存取邏輯，提供一個更物件導向的資料存取視圖。

#### 優點：
- 分離業務邏輯和資料存取邏輯
- 便於單元測試（可以使用 Mock）
- 提供一致的資料存取介面
- 支援快取策略

#### 實作範例：

```csharp
// 介面定義
public interface IRepository<T> where T : BaseEntity
{
    Task<T?> GetByIdAsync(int id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> AddAsync(T entity);
    Task<T> UpdateAsync(T entity);
    Task<bool> DeleteAsync(int id);
}

// 具體實作
public class ProductRepository : IRepository<Product>
{
    private readonly DbContext context;
    
    public ProductRepository(DbContext context)
    {
        this.context = context;
    }
    
    public async Task<Product?> GetByIdAsync(int id)
    {
        return await context.Products.FindAsync(id);
    }
    
    // 其他方法實作...
}
```

### 2.2 Unit of Work Pattern (工作單元模式)

Unit of Work 模式維護受業務交易影響的物件列表，並協調寫入變更和並行性問題的解決。

#### 優點：
- 確保資料一致性
- 批次操作優化
- 交易管理
- 減少資料庫往返次數

#### 實作範例：

```csharp
public interface IUnitOfWork : IDisposable
{
    IRepository<Product> Products { get; }
    IRepository<Inventory> Inventory { get; }
    Task<int> SaveChangesAsync();
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}

public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext context;
    private IDbContextTransaction? transaction;
    
    public UnitOfWork(DbContext context)
    {
        this.context = context;
        Products = new ProductRepository(context);
        Inventory = new InventoryRepository(context);
    }
    
    public async Task<int> SaveChangesAsync()
    {
        return await context.SaveChangesAsync();
    }
    
    // 其他方法實作...
}
```

### 2.3 Dependency Injection (依賴注入)

依賴注入是一種設計模式，用於處理依賴關係，提高程式碼的可測試性和可維護性。

#### 在 ASP.NET Core 中的使用：

```csharp
// 在 Program.cs 中註冊服務
builder.Services.AddScoped<IRepository<Product>, ProductRepository>();
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
builder.Services.AddScoped<IProductService, ProductService>();

// 在控制器中使用
public class ProductsController : ControllerBase
{
    private readonly IProductService productService;
    
    public ProductsController(IProductService productService)
    {
        this.productService = productService;
    }
    
    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetProducts()
    {
        var products = await productService.GetAllProductsAsync();
        return Ok(products);
    }
}
```

## 第三部分：實作指南

### 3.1 建立資料模型

#### 基礎實體設計：

```csharp
public abstract class BaseEntity
{
    public int Id { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public bool IsDeleted { get; set; } = false;
    public string CreatedBy { get; set; } = string.Empty;
    public string UpdatedBy { get; set; } = string.Empty;
}
```

#### 領域實體設計：

```csharp
public class Product : BaseEntity
{
    [Required]
    [StringLength(200)]
    public string Name { get; set; } = string.Empty;
    
    [Required]
    [Range(0.01, double.MaxValue)]
    public decimal Price { get; set; }
    
    // 導航屬性
    public virtual ICollection<Inventory> InventoryItems { get; set; } = new List<Inventory>();
}
```

### 3.2 實作服務層

```csharp
public interface IProductService
{
    Task<IEnumerable<Product>> GetAllProductsAsync();
    Task<Product?> GetProductByIdAsync(int id);
    Task<Product> CreateProductAsync(CreateProductDto dto);
    Task<Product> UpdateProductAsync(int id, UpdateProductDto dto);
    Task<bool> DeleteProductAsync(int id);
}

public class ProductService : IProductService
{
    private readonly IUnitOfWork unitOfWork;
    private readonly IMapper mapper;
    
    public ProductService(IUnitOfWork unitOfWork, IMapper mapper)
    {
        this.unitOfWork = unitOfWork;
        this.mapper = mapper;
    }
    
    public async Task<IEnumerable<Product>> GetAllProductsAsync()
    {
        return await unitOfWork.Products.GetAllAsync();
    }
    
    // 其他方法實作...
}
```

### 3.3 實作 API 控制器

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductService productService;
    private readonly ILogger<ProductsController> logger;
    
    public ProductsController(IProductService productService, ILogger<ProductsController> logger)
    {
        this.productService = productService;
        this.logger = logger;
    }
    
    [HttpGet]
    public async Task<ActionResult<IEnumerable<ProductDto>>> GetProducts()
    {
        try
        {
            var products = await productService.GetAllProductsAsync();
            var productDtos = mapper.Map<IEnumerable<ProductDto>>(products);
            return Ok(productDtos);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error retrieving products");
            return StatusCode(500, "Internal server error");
        }
    }
    
    // 其他端點實作...
}
```

## 第四部分：最佳實踐

### 4.1 錯誤處理

```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate next;
    private readonly ILogger<GlobalExceptionMiddleware> logger;
    
    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        this.next = next;
        this.logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await next(context);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = exception switch
        {
            NotFoundException => 404,
            ValidationException => 400,
            UnauthorizedException => 401,
            _ => 500
        };
        
        var response = new ErrorResponse
        {
            StatusCode = context.Response.StatusCode,
            Message = exception.Message
        };
        
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 4.2 資料驗證

```csharp
public class CreateProductDto
{
    [Required(ErrorMessage = "產品名稱不能為空")]
    [StringLength(200, ErrorMessage = "產品名稱長度不能超過200個字元")]
    public string Name { get; set; } = string.Empty;
    
    [Required(ErrorMessage = "產品價格不能為空")]
    [Range(0.01, double.MaxValue, ErrorMessage = "產品價格必須大於0")]
    public decimal Price { get; set; }
    
    [StringLength(1000, ErrorMessage = "產品描述長度不能超過1000個字元")]
    public string Description { get; set; } = string.Empty;
}
```

### 4.3 日誌記錄

```csharp
public class ProductService : IProductService
{
    private readonly ILogger<ProductService> logger;
    
    public ProductService(ILogger<ProductService> logger)
    {
        this.logger = logger;
    }
    
    public async Task<Product> CreateProductAsync(CreateProductDto dto)
    {
        logger.LogInformation("Creating product with name: {ProductName}", dto.Name);
        
        try
        {
            var product = mapper.Map<Product>(dto);
            var result = await unitOfWork.Products.AddAsync(product);
            await unitOfWork.SaveChangesAsync();
            
            logger.LogInformation("Product created successfully with ID: {ProductId}", result.Id);
            return result;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Error creating product with name: {ProductName}", dto.Name);
            throw;
        }
    }
}
```

## 第五部分：測試策略

### 5.1 單元測試

```csharp
[Test]
public async Task GetProductByIdAsync_ValidId_ReturnsProduct()
{
    // Arrange
    var productId = 1;
    var expectedProduct = new Product { Id = productId, Name = "Test Product" };
    
    mockRepository.Setup(r => r.GetByIdAsync(productId))
                  .ReturnsAsync(expectedProduct);
    
    // Act
    var result = await productService.GetProductByIdAsync(productId);
    
    // Assert
    Assert.That(result, Is.Not.Null);
    Assert.That(result.Id, Is.EqualTo(productId));
    Assert.That(result.Name, Is.EqualTo("Test Product"));
}
```

### 5.2 整合測試

```csharp
[Test]
public async Task CreateProduct_ValidData_CreatesProductInDatabase()
{
    // Arrange
    var createDto = new CreateProductDto
    {
        Name = "Test Product",
        Price = 99.99m
    };
    
    // Act
    var result = await client.PostAsJsonAsync("/api/products", createDto);
    
    // Assert
    result.StatusCode.Should().Be(HttpStatusCode.Created);
    
    var product = await result.Content.ReadFromJsonAsync<ProductDto>();
    product.Should().NotBeNull();
    product.Name.Should().Be("Test Product");
}
```

## 學習檢查清單

### 基礎概念
- [ ] 理解分層架構的優點和實作
- [ ] 掌握 SOLID 原則的應用
- [ ] 了解依賴注入的使用

### 設計模式
- [ ] 實作 Repository 模式
- [ ] 實作 Unit of Work 模式
- [ ] 理解其他常用設計模式

### 實作技能
- [ ] 建立完整的資料模型
- [ ] 實作服務層邏輯
- [ ] 建立 RESTful API
- [ ] 實作錯誤處理和驗證
- [ ] 撰寫單元測試和整合測試

### 最佳實踐
- [ ] 遵循程式碼規範
- [ ] 實作適當的日誌記錄
- [ ] 使用適當的異常處理
- [ ] 實作安全性考量

## 下一步學習

1. **進階架構模式**：CQRS、Event Sourcing、微服務架構
2. **效能優化**：快取策略、資料庫優化、非同步程式設計
3. **安全性**：身份驗證、授權、資料加密
4. **DevOps**：CI/CD、容器化、監控和日誌

記住：學習架構設計是一個持續的過程，需要不斷實踐和反思。透過這個專案，您將建立堅實的基礎，為未來的軟體開發做好準備。